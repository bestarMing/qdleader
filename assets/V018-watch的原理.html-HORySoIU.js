import{_ as a,c as r,b as e,o as s}from"./app-CjvLLpCW.js";const c={};function n(h,t){return s(),r("div",null,t[0]||(t[0]=[e("h1",{id:"v018-watch的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#v018-watch的原理"},[e("span",null,"V018-watch的原理")])],-1),e("h2",{id:"watch-的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#watch-的原理"},[e("span",null,"watch 的原理")])],-1),e("p",null,"watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下",-1),e("p",null,"• deep：深度监听对象，为对象的每一个属性创建一个 watcher，从而确保对象的每一个属性更新时都会触发传入的回调函数。主要原因在于对象属于引用类型，单个属性的更新并不会触发对象 setter，因此引入 deep 能够很好地解决监听对象的问题。同时也会引入判断机制，确保在多个属性更新时回调函数仅触发一次，避免性能浪费。",-1),e("p",null,"• immediate：在初始化时直接调用回调函数，可以通过在 created 阶段手动调用回调函数实现相同的效果",-1)]))}const l=a(c,[["render",n]]),o=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue%E7%AF%87/V018-watch%E7%9A%84%E5%8E%9F%E7%90%86.html","title":"V018-watch的原理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1749193496000,"contributors":[{"name":"bestarMing","username":"bestarMing","email":"49470216+bestarMing@users.noreply.github.com","commits":1,"url":"https://github.com/bestarMing"}],"changelog":[{"hash":"2ce8af76d22c8efad6164db81ee3aedf5f03b58b","time":1749193496000,"email":"49470216+bestarMing@users.noreply.github.com","author":"bestarMing","message":"Update deploy-vuepress.yml"}]},"filePathRelative":"前端面试/vue篇/V018-watch的原理.md"}');export{l as comp,o as data};
